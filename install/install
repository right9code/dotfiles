#!/bin/bash

# 'set -e' ensures that the script exits immediately if any command returns a non-zero exit status (error).
# This is a safety feature to prevent the script from continuing execution in an unstable state.
set -e

# Determine the absolute path of the directory where this script is currently located.
# 'cd --' ensures we handle directory names starting with '-' correctly.
# 'dirname -- "${BASH_SOURCE[0]}"' gets the directory name of the current script.
# '&>/dev/null' suppresses output during the cd command.
# 'pwd' prints the working directory.
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)

# Define the expected location for the dotfiles installation script.
# This enforces a specific directory structure for the installation to work correctly.
EXPECTED_PATH="$HOME/.local/share/dotfiles/install"

# Verify that the script is running from the expected path.
if [[ "$SCRIPT_DIR" != "$EXPECTED_PATH" ]]; then
  echo "ERROR: This script must be run from $EXPECTED_PATH"
  echo "Current location: $SCRIPT_DIR"
  echo ""
  echo "Please move the dotfiles folder to ~/.local/share/dotfiles and try again"
  # Exit with error code 1 if the location is incorrect.
  exit 1
fi

# Source (import) external helper scripts.
# 'helpers.sh' contains utility functions like logging and UI elements.
source "$SCRIPT_DIR/lib/helpers.sh"
# 'backup.sh' contains functions to handle backing up existing files before overwriting.
source "$SCRIPT_DIR/lib/backup.sh"

# Initialize a new backup session.
# This creates a timestamped directory to store any files that are replaced during installation.
# The function 'init_backup_session' is defined in 'lib/backup.sh'.
BACKUP_SESSION=$(init_backup_session)
log_info "Backup session: $BACKUP_SESSION"

# Ensure that the 'gum' command-line tool is installed.
# 'gum' is used to create interactive and pretty shell scripts (spinners, confirms, etc.).
ensure_gum

# Request sudo (superuser) privileges immediately.
# 'sudo -v' updates the user's cached credentials, preventing the script from pausing for a password later.
sudo -v

# Define a function to install 'yay', an AUR (Arch User Repository) helper.
# This is necessary because many dotfiles packages come from the AUR, not the official repositories.
_installYay() {
  # Check if the 'base-devel' package group is installed.
  # This group contains essential tools for building packages (gcc, make, etc.).
  if ! is_installed "base-devel"; then
    log_info "Installing base-devel..."
    sudo pacman --noconfirm -S base-devel
  fi
  
  # Check if 'git' is installed, as it is required to clone the yay repository.
  if ! is_installed "git"; then
    log_info "Installing git..."
    sudo pacman --noconfirm -S git
  fi

  log_info "Cloning yay from AUR..."
  # Remove any existing temporary yay directory to ensure a clean build.
  rm -rf /tmp/yay
  
  # Clone the yay repository from the AUR to a temporary location.
  git clone https://aur.archlinux.org/yay.git /tmp/yay
  
  # Change directory to the cloned repository.
  cd /tmp/yay
  
  log_info "Building and installing yay (this may take a moment)..."
  # Build and install the package.
  # '-s' installs missing dependencies.
  # '-i' installs the built package.
  # '--noconfirm' skips confirmation prompts.
  makepkg -si --noconfirm
  
  # Return to the home directory.
  cd ~
  
  # Clean up the temporary directory.
  rm -rf /tmp/yay
  
  log_success "Yay installed successfully"
}

# Define a function to install a list of packages from a text file.
# Arguments: $1 - Path to the file containing the list of packages.
_installPackages() {
  # Calculate the total number of packages to install for the progress bar.
  # 'grep -v' excludes comments (#) and empty lines.
  # 'wc -l' counts the lines.
  local total=$(grep -v '^#' "$1" | grep -v '^$' | wc -l)
  local current=0
  local failed_packages=()

  # Read the file line by line.
  while IFS= read -r pkg || [ -n "$pkg" ]; do
    # Skip lines that are empty or start with a comment hash (#).
    [[ -z "$pkg" || "$pkg" =~ ^# ]] && continue

    # Increment the current package counter.
    current=$((current + 1))

    # Check if the package is already installed on the system.
    if is_installed "${pkg}"; then
      log_progress "$pkg (already installed)" "$current/$total"
      continue
    fi

    # Attempt to install the package using 'yay'.
    # 'spinner' wraps the command with a loading animation.
    # '--needed' skips re-installing up-to-date packages (redundant here but good practice).
    # '2>&1' redirects stderr to stdout so we can see errors if they happen.
    if spinner "Installing $pkg... [$current/$total]" yay --noconfirm --needed -S "${pkg}" 2>&1; then
      log_success "$pkg"
    else
      # If installation fails, log an error and add the package to the failed list.
      log_error "Failed to install: $pkg"
      failed_packages+=("$pkg")
    fi
  done <"$1"

  # After the loop, check if there were any failures.
  if [ ${#failed_packages[@]} -gt 0 ]; then
    log_error "The following packages failed to install:"
    for pkg in "${failed_packages[@]}"; do
      log_detail "$pkg"
    done
    log_info "You can try installing them manually with: yay -S <package_name>"
  fi
}

# Clear the terminal screen for a fresh start.
clear
log_header "Dotfiles Installation"

# Record the start time to calculate total installation duration later.
START_TIME=$(date +%s)
TOTAL_STEPS=10
CURRENT_STEP=0

# Step 1: Check for and install 'yay' if it is missing.
if ! is_installed "yay"; then
  CURRENT_STEP=$((CURRENT_STEP + 1))
  log_step "[$CURRENT_STEP/$TOTAL_STEPS] Installing yay AUR helper"
  _installYay
fi

# Step 2: Install all packages listed in 'pkgs.txt'.
# This file typically contains tools, fonts, and applications needed for the environment.
CURRENT_STEP=$((CURRENT_STEP + 1))
log_step "[$CURRENT_STEP/$TOTAL_STEPS] Installing packages"
_installPackages "$SCRIPT_DIR/pkgs.txt"

# Step 3: Run the Zsh setup script.
# This configures the shell, installs Oh My Zsh, and plugins.
CURRENT_STEP=$((CURRENT_STEP + 1))
log_step "[$CURRENT_STEP/$TOTAL_STEPS] Installing zsh plugins"
bash "$SCRIPT_DIR/setup-zsh"

# Step 4: Run the LazyVim setup script.
# This configures the Neovim editor with the LazyVim distribution.
CURRENT_STEP=$((CURRENT_STEP + 1))
log_step "[$CURRENT_STEP/$TOTAL_STEPS] Setting up LazyVim"
bash "$SCRIPT_DIR/setup-lazyvim"

# Step 5: Run the configuration setup script.
# This copies or symlinks config files (dotfiles) to their appropriate locations in ~/.config.
CURRENT_STEP=$((CURRENT_STEP + 1))
log_step "[$CURRENT_STEP/$TOTAL_STEPS] Copying configuration files"
bash "$SCRIPT_DIR/setup-config"

# Step 6: Run hardware-specific setup.
# This might configure drivers or settings specific to laptops vs desktops (e.g., power management).
CURRENT_STEP=$((CURRENT_STEP + 1))
log_step "[$CURRENT_STEP/$TOTAL_STEPS] Hardware based setup"
bash "$SCRIPT_DIR/setup-by-hardware"

# Step 7: Run the theme setup script.
# This handles symlinking theme files (colorschemes) to various applications.
CURRENT_STEP=$((CURRENT_STEP + 1))
log_step "[$CURRENT_STEP/$TOTAL_STEPS] Creating theme symlinks"
bash "$SCRIPT_DIR/setup-theme"

# Step 8: Run Qt theming setup.
# Configures Qt5 and Qt6 applications to respect the system theme.
CURRENT_STEP=$((CURRENT_STEP + 1))
log_step "[$CURRENT_STEP/$TOTAL_STEPS] Setting up Qt theming"
bash "$SCRIPT_DIR/setup-qt-theming"

# Step 9: Run GTK4 theming setup.
# Configures GTK4 and Libadwaita applications.
CURRENT_STEP=$((CURRENT_STEP + 1))
log_step "[$CURRENT_STEP/$TOTAL_STEPS] Setting up GTK4 theming"
bash "$SCRIPT_DIR/setup-gtk4-theming"

# Step 10: Run application setup.
# Copies .desktop files to ~/.local/share/applications to make them appear in the app launcher.
CURRENT_STEP=$((CURRENT_STEP + 1))
log_step "[$CURRENT_STEP/$TOTAL_STEPS] Copying applications to ~/.local/share/applications"
bash "$SCRIPT_DIR/setup-applications"

# Step 11: Run system configuration setup.
# This handles lower-level system settings.
CURRENT_STEP=$((CURRENT_STEP + 1))
log_step "[$CURRENT_STEP/$TOTAL_STEPS] Configuring system"
bash "$SCRIPT_DIR/setup-system"

# Attempt to reload the Hyprland window manager configuration.
# '2>/dev/null' suppresses errors if Hyprland is not currently running.
hyprctl reload 2>/dev/null || log_detail "Hyprland not running, skipping reload"

# Calculate and display the total installation time.
END_TIME=$(date +%s)
TOTAL_TIME=$((END_TIME - START_TIME))
MINUTES=$((TOTAL_TIME / 60))
SECONDS=$((TOTAL_TIME % 60))

clear
log_header "Installation Complete!"
echo
log_success "Installed in ${MINUTES}m ${SECONDS}s"
echo

# Load backup session details to display to the user.
# This tells the user where their old config files were saved.
source "$HOME/.local/share/dotfiles/.dotfiles-backup-session"
log_info "Backup saved to: $BACKUP_DIR"
log_info "Restore instructions: cat $RESTORE_FILE"

# Remove the temporary session file as it is no longer needed.
rm -f "$HOME/.local/share/dotfiles/.dotfiles-backup-session"

# Mark all current update scripts as "applied".
# This prevents the system from trying to run "upgrade" scripts on a fresh install.
DOTFILES_DIR="$(dirname "$SCRIPT_DIR")"
if [ -d "$DOTFILES_DIR/updates" ]; then
  find "$DOTFILES_DIR/updates" -name "*.sh" -type f | sort | while read update; do
    echo "$(basename "$update")" >> "$DOTFILES_DIR/.updates-applied"
  done
fi

echo
log_info "Please reboot for all changes to take effect"
echo

# Display a critical warning using 'gum confirm'.
# This ensures the user sees the message about selecting the correct session at login.
gum confirm \
  --prompt.foreground=2 \
  --selected.foreground=15 \
  --selected.background=2 \
  --affirmative="OK" \
  --negative="" \
  "You have to pick Hyprland (uwsm-managed) in your login manager (like sddm, gdm, ly). Otherwise scripts will not be in PATH and will NOT WORK" || true

echo
# Ask the user if they want to reboot immediately.
if ask_yes_no "Reboot now?"; then
  clear
  # Try systemd reboot, fall back to direct reboot command.
  systemctl reboot --no-wall 2>/dev/null || reboot 2>/dev/null
fi
